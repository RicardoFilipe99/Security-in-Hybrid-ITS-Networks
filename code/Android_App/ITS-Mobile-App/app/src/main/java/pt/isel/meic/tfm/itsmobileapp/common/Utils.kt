package pt.isel.meic.tfm.itsmobileapp.common

import java.nio.ByteBuffer
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec
import kotlin.experimental.xor
import kotlin.random.Random

/**
 * Convert an hexadecimal string to byte array
 */
fun convertHexStringToByteArray(hexString: String): ByteArray {
    check(hexString.length % 2 == 0) { "String must have an even length" }

    return hexString.chunked(2)
        .map { it.toInt(16).toByte() }
        .toByteArray()
}

/**
 * Returns a generated ByteArray with the specified size
 */
fun generateByteArray(size: Int): ByteArray {
    val byteArray = ByteArray(size)
    Random.nextBytes(byteArray)
    return byteArray
}

/**
 * Customized byte utils class
 */
object ByteUtils { // An object represents a single static instance

    private val longBuffer: ByteBuffer = ByteBuffer.allocate(Long.SIZE_BYTES)
    private val intBuffer: ByteBuffer = ByteBuffer.allocate(Int.SIZE_BYTES)

    /**
     * Convert a Long value to ByteArray
     */
    fun longToBytes(x: Long): ByteArray {
        longBuffer.putLong(0, x)
        return longBuffer.array()
    }

    /**
     * Convert a ByteArray value to Long
     */
    fun bytesToLong(bytes: ByteArray): Long {
        longBuffer.put(bytes, 0, bytes.size)
        longBuffer.flip() // need flip
        return longBuffer.long
    }

    /**
     * Convert a Int value to ByteArray
     */
    fun intToBytes(x: Int): ByteArray {
        intBuffer.putInt(0, x)
        return intBuffer.array()
    }

    /**
     * Convert a ByteArray value to Int
     */
    fun bytesToInt(bytes: ByteArray): Int {
        intBuffer.put(bytes, 0, bytes.size)
        intBuffer.flip()
        return intBuffer.int
    }

    /**
     * Concatenate the byte arrays passed via parameter
     */
    fun concatenateByteArrays(vararg arrays: ByteArray): ByteArray {
        // Determine the total length of the concatenated array
        var totalLength = 0
        for (array in arrays) {
            totalLength += array.size
        }

        // Create a new byte array to hold the concatenated data
        val result = ByteArray(totalLength)

        // Use System.arraycopy() to copy the arrays into the result array
        var destPos = 0
        for (array in arrays) {
            System.arraycopy(array, 0, result, destPos, array.size)
            destPos += array.size
        }
        return result
    }

}

/**
 * Performs XOR between two ByteArray
 */
fun xorByteArrays(array1: ByteArray, array2: ByteArray): ByteArray {
    val result = ByteArray(array1.size.coerceAtMost(array2.size))

    for (i in result.indices) {
        result[i] = (array1[i] xor array2[i])
    }

    return result
}

/**
 * Customized cryptography utils class
 */
object CryptographyUtils {

    fun performDigitalSignature(key: ByteArray, message: ByteArray, algorithm: String): ByteArray {

        val secretKey = SecretKeySpec(key, algorithm)
        val mac = Mac.getInstance(algorithm)
        mac.init(secretKey)
        return mac.doFinal(message)

    }

}